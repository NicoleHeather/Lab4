**SENG 438 - Software Testing, Reliability, and Quality**

**Lab. Report \#4 â€“ Mutation Testing and Web app testing**

| Group 23:      |     |
| -------------- | --- |
| Nicole Heather |     |
| Nora Mellik    |     |
| Jennifer Jay   |     |
| Creek Thompson |     |

# Introduction
As software project becomes larger in scale and more logicically complicated, detecting errors and mistakes in code becomes increasingly difficult. Requirement and coverage based testing does well to examine a programs ability to function correctly, but if a tester does not know the possible faults in the system, how do they detect them? Mutation testing is the perfect tool to cover for the faults of the previous testing strategies. 

**Part 1: Mutation Testing**

Firstly, we'll explore **Mutation Testing**, a technique that allows us to evaluate the effectiveness of our test suites. By injecting faults, or mutations, into the source code and analyzing how well our tests detect these faults, we can gauge the quality of our testing efforts. Using **Pitest**, a powerful mutation testing tool, we'll generate mutants of the System Under Test (SUT) and measure mutation scores to improve our test suite's overall robustness.

**Objectives:**
- Gain an understanding of mutation testing and its significance.
- Measure mutation scores to assess test suite effectiveness.
- Familiarize ourselves with **Pitest** and its functionalities.

**Part 2: GUI Testing**

Next, we'll venture into the realm of **GUI Testing**, specifically focusing on automated testing. Our primary tool for this will be **Selenium**, a widely-used web-interface testing tool. We'll automate test cases on selected websites to ensure their functionality and reliability. Additionally, we'll explore an alternative tool, **Sikulix**, comparing its features and capabilities with **Selenium**.

**Objectives:**
- Familiarize ourselves with **Selenium** and **Sikulix** for automated GUI testing.
- Design and automate UI test cases for selected functionalities of target applications.
- Compare **Selenium IDE** with **Sikulix**, discussing their pros and cons.

Throughout both parts of the lab, meticulous documentation and analysis will be key. We'll record our findings, discuss strategies for improving mutation scores, evaluate the advantages and disadvantages of testing tools, and reflect on our teamwork dynamics.

# Analysis of 10 Mutants of the Range class 
5 Mutants Killed:

 - #105: Replaced double return with 0.0d for getLowerBound():

 - #132: Replaced double addition with division for getCentralValue():
  
 - #144: Greater than to equal for contains():

 - #123: Negatated double field lower for getLength():
  
 - #161: Negated double field upper for intersects(double b0, double b1):;

5 Mutants Not Killed: 



# Report all the statistics and the mutation score for each test class


# Analysis drawn on the effectiveness of each of the test classes

# A discussion on the effect of equivalent mutants on mutation score accuracy

# A discussion of what could have been done to improve the mutation score of the test suites

# Why do we need mutation testing? Advantages and disadvantages of mutation testing

# Explain your SELENUIM test case design process

In order to design our tests, we initially brainstormed what interactive elements of the eBay website could be consistently recorded and tested. The final tests were based on browsing the site ourselves and jotting down relevant functionalities that could be tested, with elements that existed that could be asserted once done. At the end of the brainstorming and traversing the website, the eight tests we came up with were Add to Cart, Sign In, Remove from Cart, Add to Watchlist, Save Seller, Invalid Login, Normal Search, and Advanced Search. Creating the test cases involved using Selenium to record the test case, which was then saved into a test case within the project file and would be run several times to ensure the functionality was working as expected.

# Explain the use of assertions and checkpoints

# how did you test each functionaity with different test data

# Discuss advantages and disadvantages of Selenium vs. Sikulix

Sikulix vs Selenium
Sikuli is used for GUI test automation and identifies objects using that are displayed on the screen. It requires an image to be stored and uses an image-based recognition system to compare how much the image matches the display GUI it is searching. This can be particularly helpful for test cases such as searching on Ebay as it can also recognize the images of the search results.
A disadvantage of Selenium is that it can only be used on web applications where as Sikulix can also be used on system applications as well. Selenium also cannot be used for image recognition and is only limited to locators that can be found in the HTML source code, where as Sikulix is not limited to the HTML source code as it compares images to anything that can be seen on screen. A disadvantage of Sikulix is that it can work only with what is displayed on the GUI. Unlike Selenium, Sikulix is unable to read text and images must be stored to test automation.

# How the team work/effort was divided and managed

# Difficulties encountered, challenges overcome, and lessons learned

# Comments/feedback on the lab itself
